{"version":3,"file":"index.js","sources":["../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","../node_modules/path-to-regexp/dist.es2015/index.js","../src/index.ts","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js"],"sourcesContent":["export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"./defineProperty.js\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    var tokens = [];\n    var i = 0;\n    while (i < str.length) {\n        var char = str[i];\n        if (char === \"*\" || char === \"+\" || char === \"?\") {\n            tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === \"{\") {\n            tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"}\") {\n            tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \":\") {\n            var name = \"\";\n            var j = i + 1;\n            while (j < str.length) {\n                var code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError(\"Missing parameter name at \" + i);\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === \"(\") {\n            var count = 1;\n            var pattern = \"\";\n            var j = i + 1;\n            if (str[j] === \"?\") {\n                throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \" + j);\n            }\n            while (j < str.length) {\n                if (str[j] === \"\\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === \"(\") {\n                    count++;\n                    if (str[j + 1] !== \"?\") {\n                        throw new TypeError(\"Capturing groups are not allowed at \" + j);\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError(\"Unbalanced pattern at \" + i);\n            if (!pattern)\n                throw new TypeError(\"Missing pattern at \" + i);\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var tokens = lexer(str);\n    var _a = options.prefixes, prefixes = _a === void 0 ? \"./\" : _a;\n    var defaultPattern = \"[^\" + escapeString(options.delimiter || \"/#?\") + \"]+?\";\n    var result = [];\n    var key = 0;\n    var i = 0;\n    var path = \"\";\n    var tryConsume = function (type) {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    var mustConsume = function (type) {\n        var value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        var _a = tokens[i], nextType = _a.type, index = _a.index;\n        throw new TypeError(\"Unexpected \" + nextType + \" at \" + index + \", expected \" + type);\n    };\n    var consumeText = function () {\n        var result = \"\";\n        var value;\n        // tslint:disable-next-line\n        while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n            result += value;\n        }\n        return result;\n    };\n    while (i < tokens.length) {\n        var char = tryConsume(\"CHAR\");\n        var name = tryConsume(\"NAME\");\n        var pattern = tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            var prefix = char || \"\";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = \"\";\n            }\n            if (path) {\n                result.push(path);\n                path = \"\";\n            }\n            result.push({\n                name: name || key++,\n                prefix: prefix,\n                suffix: \"\",\n                pattern: pattern || defaultPattern,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        var value = char || tryConsume(\"ESCAPED_CHAR\");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = \"\";\n        }\n        var open = tryConsume(\"OPEN\");\n        if (open) {\n            var prefix = consumeText();\n            var name_1 = tryConsume(\"NAME\") || \"\";\n            var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n            var suffix = consumeText();\n            mustConsume(\"CLOSE\");\n            result.push({\n                name: name_1 || (pattern_1 ? key++ : \"\"),\n                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n                prefix: prefix,\n                suffix: suffix,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        mustConsume(\"END\");\n    }\n    return result;\n}\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === \"object\") {\n            return new RegExp(\"^(?:\" + token.pattern + \")$\", reFlags);\n        }\n    });\n    return function (data) {\n        var path = \"\";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            var optional = token.modifier === \"?\" || token.modifier === \"*\";\n            var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not repeat, but got an array\");\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not be empty\");\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(\"Expected all \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            var typeOfMessage = repeat ? \"an array\" : \"a string\";\n            throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to be \" + typeOfMessage);\n        }\n        return path;\n    };\n}\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match(str, options) {\n    var keys = [];\n    var re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction(re, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;\n    return function (pathname) {\n        var m = re.exec(pathname);\n        if (!m)\n            return false;\n        var path = m[0], index = m.index;\n        var params = Object.create(null);\n        var _loop_1 = function (i) {\n            // tslint:disable-next-line\n            if (m[i] === undefined)\n                return \"continue\";\n            var key = keys[i - 1];\n            if (key.modifier === \"*\" || key.modifier === \"+\") {\n                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        };\n        for (var i = 1; i < m.length; i++) {\n            _loop_1(i);\n        }\n        return { path: path, index: index, params: params };\n    };\n}\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    var groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n    var index = 0;\n    var execResult = groupsRegex.exec(path.source);\n    while (execResult) {\n        keys.push({\n            // Use parenthesized substring match if available, index otherwise\n            name: execResult[1] || index++,\n            prefix: \"\",\n            suffix: \"\",\n            modifier: \"\",\n            pattern: \"\"\n        });\n        execResult = groupsRegex.exec(path.source);\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp(\"(?:\" + parts.join(\"|\") + \")\", flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;\n    var endsWith = \"[\" + escapeString(options.endsWith || \"\") + \"]|$\";\n    var delimiter = \"[\" + escapeString(options.delimiter || \"/#?\") + \"]\";\n    var route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var prefix = escapeString(encode(token.prefix));\n            var suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        var mod = token.modifier === \"*\" ? \"?\" : \"\";\n                        route += \"(?:\" + prefix + \"((?:\" + token.pattern + \")(?:\" + suffix + prefix + \"(?:\" + token.pattern + \"))*)\" + suffix + \")\" + mod;\n                    }\n                    else {\n                        route += \"(?:\" + prefix + \"(\" + token.pattern + \")\" + suffix + \")\" + token.modifier;\n                    }\n                }\n                else {\n                    route += \"(\" + token.pattern + \")\" + token.modifier;\n                }\n            }\n            else {\n                route += \"(?:\" + prefix + suffix + \")\" + token.modifier;\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += delimiter + \"?\";\n        route += !options.endsWith ? \"$\" : \"(?=\" + endsWith + \")\";\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === \"string\"\n            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1\n            : // tslint:disable-next-line\n                endToken === undefined;\n        if (!strict) {\n            route += \"(?:\" + delimiter + \"(?=\" + endsWith + \"))?\";\n        }\n        if (!isEndDelimited) {\n            route += \"(?=\" + delimiter + \"|\" + endsWith + \")\";\n        }\n    }\n    return new RegExp(route, flags(options));\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\n//# sourceMappingURL=index.js.map","/* eslint-disable no-param-reassign */\nimport type { History, Listener, To, Update } from 'history'\nimport { Action } from 'history'\nimport { action, computed, makeObservable, observable } from 'mobx'\nimport { match } from 'path-to-regexp'\n\ntype UnregisterCallback = ReturnType<History['listen']>\n\nconst join = (...paths: string[]) =>\n  paths.reduce((prev, curr) => `${prev.replace(/\\/$/, '')}/${curr.replace(/^\\//, '')}`)\n\nexport class RouterStore {\n  public pathList: string[] = []\n\n  public state: Update = {\n    action: Action.Pop,\n    location: {\n      key: 'default',\n      pathname: '',\n      search: '',\n      state: {},\n      hash: '',\n    },\n  }\n\n  /** @readonly */\n  public get location(): Update['location'] {\n    return this.state.location\n  }\n\n  constructor(readonly history: History, readonly basePath?: string) {\n    this.go = history.go.bind(history)\n    this.back = history.back.bind(history)\n    this.forward = history.forward.bind(history)\n\n    makeObservable(this, {\n      state: observable,\n      location: computed,\n      query: computed,\n      pathList: observable,\n      hashValue: computed,\n      pathValue: computed,\n      appendPathList: action,\n      prependPathList: action,\n    })\n\n\n    /**\n     * Listen for changes to location state in store\n     * and run listener at once\n     */\n    this.subscribe = listener => {\n      const unlisten = history.listen(listener)\n\n      listener({\n        action: history.action,\n        location: history.location,\n      })\n\n      return unlisten\n    }\n\n    this.stopSyncWithHistory = this.subscribe(this.updateState)\n  }\n\n  push(to: To, state?: any) {\n    this.history.push(this.addBasename(to), state)\n  }\n\n  replace(to: To, state?: any) {\n    this.history.replace(this.addBasename(to), state)\n  }\n\n  public go: History['go']\n\n  public back: History['back']\n\n  public forward: History['forward']\n\n\n  public updateState = action((newState: Update) => {\n    const pathname = this.basePath ? newState.location.pathname.replace(this.basePath, '') : newState.location.pathname\n\n    this.state = {\n      action: newState.action,\n      location: {\n        ...newState.location,\n        pathname\n      },\n    }\n  })\n\n  /**\n   * get query format from location.search\n   * @readonly\n   * */\n  public get query(): Record<string, any> {\n    const { search } = this.location\n    const query: Record<string, any> = {}\n    if (search) {\n      const searchParam = new URLSearchParams(search)\n      searchParam.forEach((value, name) => {\n        if (query[name]) {\n          if (Array.isArray(query[name])) {\n            query[name].push(value)\n          } else {\n            query[name] = [query[name], value]\n          }\n        } else {\n          query[name] = value\n        }\n      })\n    }\n    return query\n  }\n\n  /**\n   * get hash, not include '#'\n   * @readonly\n   * */\n  public get hashValue(): any {\n    const { hash } = this.location\n    if (hash) {\n      return hash.slice(1)\n    }\n    return ''\n  }\n\n  /**\n   * get path variable value, example:\n   * /path/:name => /path/abc\n   * router.pathValue.name => ac\n   *\n   * @readonly\n   * */\n  public get pathValue(): Record<string, string> {\n    const { pathname } = this.location\n    let param = {}\n    let hasPathValue = false\n    this.pathList.find(path => {\n      const matchResult = match(path!, { decode: decodeURIComponent })(pathname)\n      if (matchResult && matchResult) {\n        param = matchResult.params\n        hasPathValue = true\n      }\n      return hasPathValue\n    })\n    return param\n  }\n\n  /**\n   * append new path to router.pathList, like '/abc/:name'\n   * Note: the pathList order will affect pathValue\n   * */\n  public appendPathList(...pathList: string[]): void {\n    this.pathList.push(...pathList)\n  }\n\n  /**\n   * preppend new path to router.pathList, like '/abc/:name'\n   * Note: the pathList order will affect pathValue\n   * */\n  public prependPathList(...pathList: string[]): void {\n    this.pathList.unshift(...pathList)\n  }\n\n  subscribe: (listener: Listener) => UnregisterCallback\n\n  stopSyncWithHistory: UnregisterCallback\n\n  private addBasename(to: To): To {\n    if (!this.basePath) return to\n    if (typeof to === 'string') {\n      if (!to.startsWith(this.basePath)) {\n        return join(this.basePath, to)\n      }\n    } else if (to.pathname && !to.pathname.startsWith(this.basePath)) {\n      to.pathname = join(this.basePath, to.pathname)\n    }\n\n    return to\n  }\n}\n","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","i","arguments","length","source","forEach","getOwnPropertyDescriptors","defineProperties","_defineProperties","props","descriptor","parse","str","options","tokens","char","type","index","count","pattern","j","TypeError","name","code","charCodeAt","lexer","_a","prefixes","defaultPattern","escapeString","delimiter","result","path","tryConsume","mustConsume","undefined","nextType","consumeText","prefix","indexOf","suffix","modifier","name_1","pattern_1","match","re","decode","x","pathname","m","exec","params","create","_loop_1","split","map","regexpToFunction","pathToRegexp","replace","flags","sensitive","stringToRegexp","strict","_b","start","_c","end","_d","encode","endsWith","route","_i","tokens_1","token","mod","endToken","isEndDelimited","RegExp","tokensToRegexp","groupsRegex","execResult","regexpToRegexp","Array","isArray","paths","parts","join","arrayToRegexp","_len","_key","reduce","prev","curr","concat","RouterStore","history","basePath","_this","this","instance","Constructor","_classCallCheck","pathList","state","action","Action","Pop","location","search","hash","go","back","forward","updateState","newState","_objectSpread","subscribe","stopSyncWithHistory","bind","makeObservable","observable","computed","query","hashValue","pathValue","appendPathList","prependPathList","listener","unlisten","listen","protoProps","staticProps","get","to","addBasename","URLSearchParams","slice","param","hasPathValue","find","matchResult","decodeURIComponent","_this$pathList","_this$pathList2","unshift","startsWith","prototype"],"mappings":"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"}